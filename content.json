{"pages":[],"posts":[{"title":"线性表","text":"一.线性表线性表的抽象类型定义如下：123456789101112ADT 线性表（List）Data {a1,a2,a3,a4,a5}，除了第一个元素以外，每个元素只有一个前驱元素，也只有一个后驱元素。 Qperation InitList(* L) 初始化操作，建立一个空的线性表L ListEmpty(L) 判断线性表是否为空，返回Tre和False ClearList(*L) 线性表清空 GetElem(L, i, *e) 将线性表L中的第i个位置的元素返回给e ListInsert(*L, i, e) 在线性表L中的第i个位置插入新元素e ListDelete(*L, i, *e) 删除线性表第i个位置的元素，并用e返回 ListLength(L) 返回线性表L的元素个数endADT 1.顺序存储12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int ElemType;typedef struct { ElemType data[MAXSIZE]; int length;}SqList;/* 得到线性表的元素 */Status GetElem(SqList L, int i, ElemType *e){ if (L.length == 0 || i &lt; 1 || i &gt; L.length) { return FAIL; } *e = L.data[i-1]; return SUCCESS;}/* 插入元素 */Status InsertElem(SqList *L, int i, ElemType e){ int k; if (L-&gt;length == MAXSIZE) { return FAIL; } if (i &lt; 1 || i &gt; L-&gt;length) { return FAIL; } if (i &lt;= L-&gt;length) { for (k = L-&gt;length - 1 ; k &gt;= i - 1; k--) { L-&gt;data[k+1] = L-&gt;data[k]; } } L-&gt;data[i-1] = e; L-&gt;length++; return SUCCESS;}/* 删除表中元素 */Status ListDelete(SqList *L, int i, ElemType *e){ int k; if (L-&gt;length == 0) { return FAIL; } if (i &lt; 1 || i &gt; L-&gt;length) { return FAIL; } *e = L-&gt;data[i-1]; if (i &lt; L-&gt;length) { for (k = i - 1; k &lt; L-&gt;length - 1; k++) { L-&gt;data[k] = L-&gt;data[k+1]; } } L-&gt;length--; return SUCCESS;}Status PrintList(SqList L) { if (L.length &lt;= 0) return FAIL; int i; for(i = 0; i &lt; L.length; i++) { printf(&quot;List[%d] = %d\\n&quot;, i, L.data[i]); } return SUCCESS;} 优点：可以快速存取表中任一位置的元素，存取读取的复杂度为O（1） 缺点：插入和删除需要移动大量元素，当线性表长度变化时，难以确定存储空间的容量，造成存储碎片。 2.链表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int ElemType;typedef int Status;typedef struct Node{ ElemType data; struct Node *next;} Node;typedef struct Node *LinkList;/* 获取链表中的元素 */Status GetElem(LinkList head, int i, ElemType *e){ int j; LinkList p; p = head; j = 1; while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } if (p == NULL || j &gt; i) { return FAIL; } *e = p-&gt;data; return SUCCESS;} /* 插入节点 */Status ListInsert(LinkList *head, int i, ElemType e){ int j; LinkList p, s; p = *head; j = 1; while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } if (p == NULL) { return FAIL; } s = (LinkList)malloc(sizeof(struct Node)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; // s = (LinkList)malloc(sizeof(struct Node)); // s-&gt;data = e; // s-&gt;next = *head; // *head = s; return SUCCESS;}/* 删除节点 */Status ListDelete(LinkList head, int i, ElemType *e){ int j; LinkList p, q; p = head; j = 1; while (p-&gt;next &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } if (p-&gt;next == NULL) { return FAIL; } q = p-&gt;next; p-&gt;next = q-&gt;next; *e = q-&gt;data; free(q); return SUCCESS;}Status PrintList(LinkList head){ LinkList p; p = head; if (p == NULL) { return FAIL; } while (p) { printf(&quot;%d\\n&quot;, p-&gt;data); p = p-&gt;next; } printf(&quot;\\n&quot;); return SUCCESS;}/* 尾部插入数据 */Status CreateListTail(LinkList *L, int n){ LinkList p, r; *L = (LinkList)malloc(sizeof(Node)); r = *L; int i = 0; for (i = 0; i &lt; n-1; i++) { p = (LinkList)malloc(sizeof(Node)); p-&gt;data = i; r-&gt;next = p; r = p;\\ } r-&gt;next = NULL;}/* 表格删除 */Status clearList(LinkList *L){ LinkList p; while (*L) { p = *L; *L = (*L)-&gt;next; free(p); } *L = NULL; return SUCCESS;} 二.栈和队列栈的抽象数据类型123456789101112ADT 栈（stack）Data同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系Operation InitStack(* S) 初始化操作，建立一个空栈 DestoryStack(*S) 若栈存在，则销毁它 ClearStack(*S) 将栈清空 StackEmpty(S) 若栈为空，返回True，否则返回False GetTop(S, *e) 若栈存在且非空，用e返回S的栈顶元素 Push(*S, e) 若栈存在，插入新元素e到栈中并成为栈顶元素 Pop(*S, *e) 删除栈S中栈顶元素，并用e返回 StackLength(S) 返回栈S的元素个数 1. 顺序存储的栈1234567891011121314151617181920212223242526272829303132333435363738#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int SElemType;typedef struct { SElemType data[MAXSIZE]; int top;}SqStack;Status Push(SqStack *S, SElemType e) { if (S-&gt;top == MAXSIZE - 1) { return FAIL; } S-&gt;top++; S-&gt;data[S-&gt;top] = e; return SUCCESS;}Status Pop(SqStack *S, SElemType *e) { if (S-&gt;top == -1) { return FAIL; } *e = S-&gt;data[S-&gt;top]; S-&gt;top--; return SUCCESS;}Status Print(SqStack *S) { if (S-&gt;top == -1) { return FAIL; } int i = 0; for (i; i &lt; S-&gt;top + 1; i++) { printf(&quot;%d\\t&quot;, S-&gt;data[i]); }} 2.栈的链式存储结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int SElemType;typedef struct StackNode { SElemType data; struct StackNode *next;}*LinkStackPtr;typedef struct LinkStack { LinkStackPtr top; int count;}LinkStack;Status Push(LinkStack *S, SElemType e){ LinkStackPtr s = (LinkStackPtr)malloc(sizeof(struct StackNode)); s-&gt;data = e; s-&gt;next = S-&gt;top; S-&gt;top = s; S-&gt;count++; return SUCCESS;}Status StackEmpty(LinkStack *S){ if (S-&gt;count &lt;= 0) { return SUCCESS; } return FAIL;}Status Pop(LinkStack *S, SElemType *e){ LinkStackPtr p; p = S-&gt;top; *e = S-&gt;top-&gt;data; S-&gt;top = S-&gt;top-&gt;next; free(p); S-&gt;count--; return SUCCESS;}Status Print(LinkStack *S){ int i; LinkStackPtr p; p = S-&gt;top; for (i = 0; i &lt; S-&gt;count; i++) { printf(&quot;%d\\t&quot;, p-&gt;data); p = p-&gt;next; } return SUCCESS;}int main(int argc, char**argv){ LinkStack linkstack; linkstack.top = NULL; linkstack.count = 0; Push(&amp;linkstack, 100); Push(&amp;linkstack, 200); Push(&amp;linkstack, 300); SElemType e; Pop(&amp;linkstack, &amp;e); Print(&amp;linkstack);} 3. 栈的利用：四则运算表达式，因为加减乘除还要加上（）,因此四则运算必须要利用栈来实现 后缀表达式可以利用栈来计算得到结果 9+（3-1）* 3 + 10 / 2 中缀表达式 ———&gt; 9 3 1 - 3 * + 10 2 / 后缀表示式1.将中缀表达式转化为后缀表达式（栈用来进出运算的符号）2.将后缀表达式运行结果进行输出（栈用来进出运算的数字） 队列的抽象数据类型12345678910111213ADT (Queue)Data 同线性表，元素有相同的类型， 相邻元素有前驱和后继 Operation InitQueue(*Q) 初始化队列 DestoryQueue(*Q) 销毁队列 ClearQueue(*Q) 将队列清空 QueueEmpty(Q) 若队列Q为空，返回True，否则返回false GetHead(Q, *e) 若队列存在，返回队列头 EnQueue(*Q, e) 若队列Q存在，插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q, *e) 删除队列Q队头元素，并用e返回其值 QueueLength(Q) 返回队列Q的元素个数endADT 1. 队列的顺序存储类型12345678910111213141516171819202122232425262728293031323334353637383940414243#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int QElemType;typedef struct { QElemType data[MAXSIZE]; int front; int rear;} SqQueue;Status InitQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return SUCCESS;}Status QueueLength(SqQueue Q){ return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;}Status EnQueue(Squeue *Q, QElemType e){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) { return FAIL; } Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; return SUCCESS;}Status DEQueue(SqQueue *Q, QElemType *e){ if (Q-&gt;front == Q-&gt;reae) return FAIL; *e = Q-&gt;data[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; return SUCCESS;} 2. 队列的链式存储结构1234567891011121314151617181920212223242526272829303132333435363738#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int status;typedef int QElemType;typedef struct QNode { QElemType data; struct QNode *next;} QNode, *QueuePrt;typedef struct { QueuePrt head, rear;} LinkQueue;status EnQueue(LinkQueue *Q, QElemType e){ QueuePrt s = (QueuePrt)malloc(sizeof(QNode)); s-&gt;data = e; s-&gt;next = NULL; Q-&gt;rear-&gt;next = s; Q-&gt;rear = s; return SUCCESS;}status DEQueue(LinkQueue Q, QElemtype *e){ QueuePrt p; if (Q-&gt;head == Q-&gt;rear) { return FAIL; } p = Q-&gt;head; *e = Q-&gt;head-&gt;data; Q-&gt;head = Q-&gt;head-&gt;next; free(p); return SUCCESS;}","link":"/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"title":"栈和队列","text":"二.栈和队列栈的抽象数据类型123456789101112ADT 栈（stack）Data同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系Operation InitStack(* S) 初始化操作，建立一个空栈 DestoryStack(*S) 若栈存在，则销毁它 ClearStack(*S) 将栈清空 StackEmpty(S) 若栈为空，返回True，否则返回False GetTop(S, *e) 若栈存在且非空，用e返回S的栈顶元素 Push(*S, e) 若栈存在，插入新元素e到栈中并成为栈顶元素 Pop(*S, *e) 删除栈S中栈顶元素，并用e返回 StackLength(S) 返回栈S的元素个数 1. 顺序存储的栈1234567891011121314151617181920212223242526272829303132333435363738#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int SElemType;typedef struct { SElemType data[MAXSIZE]; int top;}SqStack;Status Push(SqStack *S, SElemType e) { if (S-&gt;top == MAXSIZE - 1) { return FAIL; } S-&gt;top++; S-&gt;data[S-&gt;top] = e; return SUCCESS;}Status Pop(SqStack *S, SElemType *e) { if (S-&gt;top == -1) { return FAIL; } *e = S-&gt;data[S-&gt;top]; S-&gt;top--; return SUCCESS;}Status Print(SqStack *S) { if (S-&gt;top == -1) { return FAIL; } int i = 0; for (i; i &lt; S-&gt;top + 1; i++) { printf(&quot;%d\\t&quot;, S-&gt;data[i]); }} 2.栈的链式存储结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int SElemType;typedef struct StackNode { SElemType data; struct StackNode *next;}*LinkStackPtr;typedef struct LinkStack { LinkStackPtr top; int count;}LinkStack;Status Push(LinkStack *S, SElemType e){ LinkStackPtr s = (LinkStackPtr)malloc(sizeof(struct StackNode)); s-&gt;data = e; s-&gt;next = S-&gt;top; S-&gt;top = s; S-&gt;count++; return SUCCESS;}Status StackEmpty(LinkStack *S){ if (S-&gt;count &lt;= 0) { return SUCCESS; } return FAIL;}Status Pop(LinkStack *S, SElemType *e){ LinkStackPtr p; p = S-&gt;top; *e = S-&gt;top-&gt;data; S-&gt;top = S-&gt;top-&gt;next; free(p); S-&gt;count--; return SUCCESS;}Status Print(LinkStack *S){ int i; LinkStackPtr p; p = S-&gt;top; for (i = 0; i &lt; S-&gt;count; i++) { printf(&quot;%d\\t&quot;, p-&gt;data); p = p-&gt;next; } return SUCCESS;}int main(int argc, char**argv){ LinkStack linkstack; linkstack.top = NULL; linkstack.count = 0; Push(&amp;linkstack, 100); Push(&amp;linkstack, 200); Push(&amp;linkstack, 300); SElemType e; Pop(&amp;linkstack, &amp;e); Print(&amp;linkstack);} 3. 栈的利用：四则运算表达式，因为加减乘除还要加上（）,因此四则运算必须要利用栈来实现 后缀表达式可以利用栈来计算得到结果 9+（3-1）* 3 + 10 / 2 中缀表达式 ———&gt; 9 3 1 - 3 * + 10 2 / 后缀表示式1.将中缀表达式转化为后缀表达式（栈用来进出运算的符号）2.将后缀表达式运行结果进行输出（栈用来进出运算的数字） 队列的抽象数据类型12345678910111213ADT (Queue)Data 同线性表，元素有相同的类型， 相邻元素有前驱和后继 Operation InitQueue(*Q) 初始化队列 DestoryQueue(*Q) 销毁队列 ClearQueue(*Q) 将队列清空 QueueEmpty(Q) 若队列Q为空，返回True，否则返回false GetHead(Q, *e) 若队列存在，返回队列头 EnQueue(*Q, e) 若队列Q存在，插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q, *e) 删除队列Q队头元素，并用e返回其值 QueueLength(Q) 返回队列Q的元素个数endADT 1. 队列的顺序存储类型12345678910111213141516171819202122232425262728293031323334353637383940414243#define MAXSIZE 50#define SUCCESS 0#define FAIL 1typedef int Status;typedef int QElemType;typedef struct { QElemType data[MAXSIZE]; int front; int rear;} SqQueue;Status InitQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return SUCCESS;}Status QueueLength(SqQueue Q){ return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;}Status EnQueue(Squeue *Q, QElemType e){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) { return FAIL; } Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; return SUCCESS;}Status DEQueue(SqQueue *Q, QElemType *e){ if (Q-&gt;front == Q-&gt;reae) return FAIL; *e = Q-&gt;data[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; return SUCCESS;} 2. 队列的链式存储结构#define MAXSIZE 50 #define SUCCESS 0 #define FAIL 1 typedef int status; typedef int QElemType; typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePrt; typedef struct { QueuePrt head, rear; } LinkQueue; status EnQueue(LinkQueue *Q, QElemType e) { QueuePrt s = (QueuePrt)malloc(sizeof(QNode)); s-&gt;data = e; s-&gt;next = NULL; Q-&gt;rear-&gt;next = s; Q-&gt;rear = s; return SUCCESS; } status DEQueue(LinkQueue Q, QElemtype *e) { QueuePrt p; if (Q-&gt;head == Q-&gt;rear) { return FAIL; } p = Q-&gt;head; *e = Q-&gt;head-&gt;data; Q-&gt;head = Q-&gt;head-&gt;next; free(p); return SUCCESS; }","link":"/2021/05/23/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[],"categories":[]}